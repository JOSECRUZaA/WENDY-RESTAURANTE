-- ==============================================================================
-- 1. LIMPIEZA Y DEFINICIÓN DE TIPOS (ENUMS)
-- ==============================================================================

-- Definición de Roles y Estados
CREATE TYPE user_role AS ENUM ('administrador', 'cajero', 'garzon');
CREATE TYPE order_status AS ENUM ('pendiente', 'en_proceso', 'servido', 'pagado', 'cancelado');
CREATE TYPE item_status AS ENUM ('pendiente', 'en_preparacion', 'listo_para_servir', 'entregado', 'cancelado');
CREATE TYPE production_area AS ENUM ('cocina', 'bar', 'otro');
CREATE TYPE table_status AS ENUM ('libre', 'ocupada', 'pidio_cuenta');
CREATE TYPE payment_method AS ENUM ('efectivo', 'tarjeta', 'qr', 'transferencia');

-- ==============================================================================
-- 2. CREACIÓN DE TABLAS (ESTRUCTURA)
-- ==============================================================================

-- 2.1 TABLA DE USUARIOS (PERFILES PÚBLICOS)
CREATE TABLE public.profiles (
  id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,
  carnet_identidad TEXT UNIQUE NOT NULL,
  nombre_completo TEXT NOT NULL,
  email TEXT, -- Copia del email para facilitar busquedas
  rol user_role NOT NULL DEFAULT 'garzon',
  activo BOOLEAN DEFAULT true, -- Soft Delete: false = desactivado
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

-- 2.2 TABLA DE PRODUCTOS (MENÚ Y STOCK)
CREATE TABLE public.products (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre TEXT NOT NULL,
  descripcion TEXT,
  precio DECIMAL(10,2) NOT NULL CHECK (precio >= 0), -- Moneda: Bolivianos (Bs)
  area production_area NOT NULL,
  foto_url TEXT,
  
  -- Control de Stock Estricto
  controla_stock BOOLEAN DEFAULT false,
  stock_actual INT DEFAULT 0,
  disponible BOOLEAN DEFAULT true, -- Interruptor ON/OFF
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

-- 2.3 TABLA DE MESAS
CREATE TABLE public.mesas (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  numero_mesa INT UNIQUE NOT NULL,
  capacidad INT DEFAULT 4,
  estado table_status DEFAULT 'libre',
  orden_actual_id BIGINT -- Se vinculará más abajo para evitar error circular
);

-- 2.4 TABLA DE ÓRDENES (CABECERA)
CREATE TABLE public.orders (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  numero_mesa INT NOT NULL, 
  garzon_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL, -- Historial seguro
  cajero_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  estado order_status DEFAULT 'pendiente',
  
  -- Pagos y Auditoría
  total DECIMAL(10,2) DEFAULT 0.00, -- Moneda: Bolivianos (Bs)
  metodo_pago payment_method,
  cancelado_por UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  motivo_cancelacion TEXT,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
  
  CONSTRAINT fk_mesa FOREIGN KEY (numero_mesa) REFERENCES public.mesas(numero_mesa) ON UPDATE CASCADE
);

-- Vincular Mesa con Orden (Foreign Key circular)
ALTER TABLE public.mesas 
ADD CONSTRAINT fk_orden_actual 
FOREIGN KEY (orden_actual_id) REFERENCES public.orders(id) ON DELETE SET NULL;

-- 2.5 TABLA DE DETALLES (ITEMS DEL PEDIDO)
CREATE TABLE public.order_items (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  order_id BIGINT REFERENCES public.orders(id) ON DELETE CASCADE,
  product_id BIGINT REFERENCES public.products(id) ON DELETE RESTRICT,
  
  cantidad INT DEFAULT 1 CHECK (cantidad > 0),
  nota_especial TEXT, 
  estado item_status DEFAULT 'pendiente',
  
  -- Precios históricos
  precio_unitario DECIMAL(10,2) NOT NULL, -- Bs
  subtotal DECIMAL(10,2) GENERATED ALWAYS AS (cantidad * precio_unitario) STORED,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

-- 2.6 TABLA DE SESIONES DE CAJA (TURNO/CAJA)
CREATE TABLE public.cash_sessions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  cajero_id UUID REFERENCES public.profiles(id) NOT NULL,
  monto_apertura DECIMAL(10,2) NOT NULL DEFAULT 0.00,
  monto_cierre DECIMAL(10,2),
  monto_sistema DECIMAL(10,2),
  diferencia DECIMAL(10,2) GENERATED ALWAYS AS (monto_cierre - monto_sistema) STORED,
  
  estado TEXT DEFAULT 'abierta' CHECK (estado IN ('abierta', 'cerrada')),
  observaciones TEXT,
  
  opened_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
  closed_at TIMESTAMP WITH TIME ZONE
);

-- ==============================================================================
-- 3. LÓGICA DE NEGOCIO (FUNCIONES Y TRIGGERS)
-- ==============================================================================

-- 3.1 GESTIÓN DE USUARIOS (SYNC AUTH -> PROFILES)
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  INSERT INTO public.profiles (id, carnet_identidad, nombre_completo, email, rol)
  VALUES (
    new.id,
    COALESCE(new.raw_user_meta_data->>'carnet', 'SIN-CI-' || substr(new.id::text, 1, 8)),
    COALESCE(new.raw_user_meta_data->>'nombre', 'Usuario Nuevo'),
    new.email, -- Sync email
    COALESCE((new.raw_user_meta_data->>'rol')::user_role, 'garzon')
  );
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();


-- 3.2 CONTROL DE STOCK ESTRICTO (BLOQUEO DE VENTA)
CREATE OR REPLACE FUNCTION public.descontar_stock()
RETURNS trigger AS $$
DECLARE
  v_stock_actual INT;
  v_controla_stock BOOLEAN;
  v_nombre TEXT;
  v_disponible BOOLEAN;
BEGIN
  SELECT stock_actual, controla_stock, nombre, disponible
  INTO v_stock_actual, v_controla_stock, v_nombre, v_disponible
  FROM public.products WHERE id = NEW.product_id;

  IF v_disponible = false THEN
     RAISE EXCEPTION 'El producto % no está disponible actualmente.', v_nombre;
  END IF;

  IF v_controla_stock = true THEN
    IF v_stock_actual < NEW.cantidad THEN
      RAISE EXCEPTION 'STOCK INSUFICIENTE: Solo quedan % unidades de %.', v_stock_actual, v_nombre;
    ELSE
      UPDATE public.products 
      SET stock_actual = stock_actual - NEW.cantidad
      WHERE id = NEW.product_id;
      
      IF (v_stock_actual - NEW.cantidad) = 0 THEN
         UPDATE public.products SET disponible = false WHERE id = NEW.product_id;
      END IF;
    END IF;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tr_descontar_stock_estricto
  BEFORE INSERT ON public.order_items
  FOR EACH ROW EXECUTE PROCEDURE public.descontar_stock();


-- 3.3 DEVOLUCIÓN DE STOCK (AL CANCELAR ITEM O BORRAR)
CREATE OR REPLACE FUNCTION public.devolver_stock()
RETURNS trigger AS $$
BEGIN
  -- Caso 1: DELETE
  IF (TG_OP = 'DELETE') THEN
     UPDATE public.products
     SET stock_actual = stock_actual + OLD.cantidad,
         disponible = true
     WHERE id = OLD.product_id AND controla_stock = true;
     RETURN OLD;
  
  -- Caso 2: STATUS CANCELADO
  ELSIF (TG_OP = 'UPDATE') THEN
     IF (NEW.estado = 'cancelado' AND OLD.estado != 'cancelado') THEN
        UPDATE public.products
        SET stock_actual = stock_actual + OLD.cantidad,
            disponible = true
        WHERE id = OLD.product_id AND controla_stock = true;
     END IF;
     RETURN NEW;
  END IF;
  
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tr_devolver_stock
  AFTER DELETE OR UPDATE ON public.order_items
  FOR EACH ROW EXECUTE PROCEDURE public.devolver_stock();


-- 3.4 AUTOMATIZACIÓN DE MESAS (BLOQUEO Y LIBERACIÓN)
CREATE OR REPLACE FUNCTION public.bloquear_mesa()
RETURNS trigger AS $$
BEGIN
  IF EXISTS (SELECT 1 FROM public.mesas WHERE numero_mesa = NEW.numero_mesa AND estado != 'libre') THEN
    RAISE EXCEPTION 'La mesa % está ocupada. Cobre primero.', NEW.numero_mesa;
  END IF;

  UPDATE public.mesas 
  SET estado = 'ocupada', orden_actual_id = NEW.id
  WHERE numero_mesa = NEW.numero_mesa;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tr_bloquear_mesa_orden
  AFTER INSERT ON public.orders
  FOR EACH ROW EXECUTE PROCEDURE public.bloquear_mesa();

CREATE OR REPLACE FUNCTION public.liberar_mesa()
RETURNS trigger AS $$
BEGIN
  IF NEW.estado IN ('pagado', 'cancelado') AND OLD.estado NOT IN ('pagado', 'cancelado') THEN
    UPDATE public.mesas 
    SET estado = 'libre', orden_actual_id = NULL
    WHERE orden_actual_id = NEW.id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tr_liberar_mesa_cobro
  AFTER UPDATE ON public.orders
  FOR EACH ROW EXECUTE PROCEDURE public.liberar_mesa();

-- ==============================================================================
-- 4. SEGURIDAD (RLS)
-- ==============================================================================

ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.order_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.cash_sessions ENABLE ROW LEVEL SECURITY;

-- Solo usuarios activos pueden leer perfiles
CREATE POLICY "Lectura Perfiles publica" ON public.profiles FOR SELECT USING (auth.role() = 'authenticated' AND activo = true);

CREATE POLICY "Ver Productos" ON public.products FOR SELECT USING (true);
CREATE POLICY "Admin Gestiona Productos" ON public.products FOR ALL USING (
  EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND rol = 'administrador')
);

CREATE POLICY "Staff Gestiona Ordenes" ON public.orders FOR ALL USING (auth.role() = 'authenticated');
CREATE POLICY "Staff Gestiona Items" ON public.order_items FOR ALL USING (auth.role() = 'authenticated');

CREATE POLICY "Cajeros gestionan su caja" ON public.cash_sessions FOR ALL USING (auth.uid() = cajero_id);
CREATE POLICY "Admins ven todas las cajas" ON public.cash_sessions FOR SELECT USING (
  EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND rol = 'administrador')
);

-- ==============================================================================
-- 5. REPORTES Y VISTAS
-- ==============================================================================
CREATE OR REPLACE VIEW public.reporte_cierre_diario AS
SELECT 
  p.nombre AS producto,
  p.area,
  SUM(oi.cantidad) AS cantidad_vendida,
  SUM(oi.subtotal) AS total_dinero,
  p.stock_actual
FROM public.order_items oi
JOIN public.orders o ON oi.order_id = o.id
JOIN public.products p ON oi.product_id = p.id
WHERE o.estado = 'pagado' 
AND DATE(o.created_at) = CURRENT_DATE
GROUP BY p.id, p.nombre, p.area, p.stock_actual;

-- ==============================================================================
-- 6. INDICES
-- ==============================================================================
CREATE INDEX idx_orders_mesa ON public.orders(numero_mesa);
CREATE INDEX idx_orders_garzon ON public.orders(garzon_id);
CREATE INDEX idx_orders_cajero ON public.orders(cajero_id);
CREATE INDEX idx_order_items_product ON public.order_items(product_id);
CREATE INDEX idx_order_items_order ON public.order_items(order_id);

-- ==============================================================================
-- 7. SEED DATA
-- ==============================================================================
INSERT INTO public.mesas (numero_mesa) SELECT generate_series(1, 10);
INSERT INTO public.products (nombre, precio, area, controla_stock, stock_actual) VALUES
('Asado Especial', 45.00, 'cocina', true, 20),
('Sopa de Mani', 12.00, 'cocina', true, 15),
('Cerveza Paceña', 20.00, 'bar', true, 48),
('Coca Cola 2L', 25.00, 'bar', true, 10),
('Servicio/Cubierto', 0.00, 'otro', false, 0);

-- ==============================================================================
-- 8. REALTIME
-- ==============================================================================
alter publication supabase_realtime add table public.mesas;
alter publication supabase_realtime add table public.orders;
alter publication supabase_realtime add table public.order_items;
alter publication supabase_realtime add table public.cash_sessions;
